{"pages":[],"posts":[{"title":"Hello World &#x2F;&#x2F;写在全站开头","text":"之前用过WordPress和Typecho，但苦于国内域名备案，最后选择Github Pages + Hexo. 1printf(&quot;Hello Hexo!&quot;); 1print(&quot;Hello Hexo!&quot;)","link":"/archives/9f8ca334.html"},{"title":"Python模拟操作系统进程调度","text":"参考自CSDN：https://blog.csdn.net/qq_40877371/article/details/103753581 侵删 在原作基础上稍有改动，以及仅保留了先来先服务(FCFS)、短作业优先(SJF)、时间片轮转(RR)三种调度算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271'''参考链接：https://blog.csdn.net/qq_40877371/article/details/103753581'''#1. 先来先服务 FCFS#2. 短作业优先 SJF#3. 时间片轮转 RRimport copyimport randomclass PCB: def __init__(self, pid, name, priority, in_time, run_time): self.pid = pid #进程pid self.name = name #进程名称 self.priority = priority #进程优先级 self.in_time = in_time #进程到达时间 self.run_time = run_time #进程运行时间 self.dy_priority = priority #动态优先级 self.prialter_time = 999 #动态优先级上次修改时间 self.in_times = 0 #进入过cpu的次数 self.remain_time = run_time #工作剩余时间 self.cpu_time = 0 #占用cpu的工作时间 self.start_time = 999 # 进程开始运行时间 self.out_time = 999 # 进程运行结束时间 self.turnaround_time = 999 #周转时间 self.Wturnaround_time = 999 #带权周转时间 def pre_output(self): #运行前进程表 print(&quot;PID &quot;+str(self.pid) +&quot;\\t&quot;+ &quot;名称:&quot; + self.name +'\\t'+&quot;优先级:&quot;+ str(self.priority) +'\\t'+&quot;到达时间:&quot;+str(self.in_time) +'\\t'+&quot;运行时间:&quot;+ str(self.run_time)) def run_output(self): print(&quot;PID &quot; + str(self.pid) +'\\t'+&quot;剩余时间:&quot;+ str(self.remain_time) +'\\t'+ &quot;已工作时间:&quot; + str(self.cpu_time)) def fin_output(self): # turnaround_time = self.out_time - self.in_time #周转时间 # Wturnaround_time = turnaround_time / self.run_time #带权周转时间 print(&quot;PID &quot;+ str(self.pid) +&quot;\\t&quot;+ &quot;名称:&quot; + self.name +&quot;\\t&quot;+ &quot;优先级:&quot; + str(self.priority) +&quot;\\t&quot;+ &quot;到达时间:&quot; + str(self.in_time) +&quot;\\t&quot;+ &quot;运行时间:&quot; + str(self.cpu_time) +&quot;\\t&quot;+ &quot;开始时间:&quot; + str(self.start_time) +&quot;\\t&quot;+ &quot;结束时间:&quot; + str(self.out_time) +&quot;\\t&quot;+ &quot;周转时间:&quot; + str(self.turnaround_time)+ &quot;\\t&quot;+ &quot;带权周转时间:&quot; + str(self.Wturnaround_time))def FCFS(pcb_list): time = 0 finish_list = [] #完成后的进程组 while pcb_list: print(&quot;-&quot;*20) print(&quot;当前时间：&quot;, time) if time &gt;= pcb_list[0].in_time: if pcb_list[0].in_times == 0: print(&quot;进程&quot; + str(pcb_list[0].pid) + &quot; 开始运行&quot;) pcb_list[0].start_time = time pcb_list[0].in_times += 1 pcb_list[0].cpu_time += 1 pcb_list[0].run_output() if pcb_list[0].run_time == pcb_list[0].cpu_time: print(&quot;进程&quot; + str(pcb_list[0].pid) + &quot; 运行结束&quot;) pcb_list[0].out_time = time + 1 pcb_list[0].turnaround_time = pcb_list[0].out_time - pcb_list[0].in_time pcb_list[0].Wturnaround_time = round(pcb_list[0].turnaround_time / pcb_list[0].run_time, 2) finish_list.append(pcb_list[0]) pcb_list.remove(pcb_list[0]) time += 1 ''' for i in finish_list: AvgTurnaround_time += i.turnaround_time AvgWTurnaround_time += i.Wturnaround_time ''' return finish_listdef SJF(pcb_list): time = 0 finish_list = [] #完成后的进程组 min_time = 0 is_run = False def ListSort_SJF(sortlist): ready_num = 0 for i in sortlist: if time &gt;= i.in_time: ready_num += 1 if i.run_time &lt; min_time: temp = i sortlist.remove(i) sortlist.insert(0, temp) if ready_num &gt; 1:#防止到达时间偏后的排列在前 for j in range(ready_num - 1): for k in range(j+1, ready_num): if pcb_list[j].run_time &gt; pcb_list[k].run_time: pcb_list[j].run_time, pcb_list[k].run_time = pcb_list[k].run_time, pcb_list[j].run_time return sortlist while pcb_list: print(&quot;-&quot;*20) print(&quot;当前时间：&quot;, time) if is_run == False: pcb_list = ListSort_SJF(pcb_list) if time &gt;= pcb_list[0].in_time: is_run = True if pcb_list[0].in_times == 0: print(&quot;进程&quot; + str(pcb_list[0].pid) + &quot; 开始运行&quot;) pcb_list[0].start_time = time pcb_list[0].in_times += 1 pcb_list[0].cpu_time += 1 pcb_list[0].run_output() if pcb_list[0].run_time == pcb_list[0].cpu_time: print(&quot;进程&quot; + str(pcb_list[0].pid) + &quot; 运行结束&quot;) pcb_list[0].out_time = time + 1 pcb_list[0].turnaround_time = pcb_list[0].out_time - pcb_list[0].in_time pcb_list[0].Wturnaround_time = round(pcb_list[0].turnaround_time / pcb_list[0].run_time, 2) finish_list.append(pcb_list[0]) pcb_list.remove(pcb_list[0]) is_run = False time += 1 return finish_listdef RR(pcb_list): time = 0 finish_list =[] remove_time = pcb_list[0].in_time - 1 def ListSort_RR(sortlist): ready_num = 0 pcb_newlist = [] for i in sortlist: if time &gt;= i.in_time: ready_num += 1 if i.in_times == 0: pcb_newlist.append(i.pid) if ready_num &gt; 1: if time - 1 != remove_time: temp = sortlist.pop(0) sortlist.insert(ready_num-1 ,temp) if pcb_newlist: pcb_newlist.clear() return sortlist while pcb_list: print(&quot;-&quot;*20) print(&quot;当前时间：&quot;, time) pcb_list = ListSort_RR(pcb_list) if time &gt;= pcb_list[0].in_time: if pcb_list[0].in_times == 0: print(&quot;进程&quot; + str(pcb_list[0].pid) + &quot; 开始运行&quot;) pcb_list[0].start_time = time pcb_list[0].in_times += 1 pcb_list[0].cpu_time += 1 pcb_list[0].remain_time -= 1 if pcb_list[0].dy_priority: pcb_list[0].dy_priority -= 1 pcb_list[0].prialter_time = time pcb_list[0].run_output() if pcb_list[0].remain_time == 0: print(&quot;进程&quot; + str(pcb_list[0].pid) + &quot; 运行结束&quot;) pcb_list[0].out_time = time + 1 pcb_list[0].turnaround_time = pcb_list[0].out_time - pcb_list[0].in_time pcb_list[0].Wturnaround_time = round(pcb_list[0].turnaround_time / pcb_list[0].run_time, 2) finish_list.append(pcb_list[0]) pcb_list.remove(pcb_list[0]) remove_time = time time += 1 return finish_listdef ListSort(pcb_list): for i in range(len(pcb_list)-1): for j in range(i+1, len(pcb_list)): if pcb_list[i].pid &gt; pcb_list[j].pid: pcb_list[i],pcb_list[j] = pcb_list[j],pcb_list[i] for i in pcb_list: if i.start_time == 999: if int(i.pid)==0: print(&quot;-&quot;*20) i.pre_output() else: if int(i.pid)==0: print(&quot;-&quot;*20) i.fin_output() return pcb_listdef NewList_random(num): pcb_list = [] name_list = [&quot;分配主存空间&quot;, &quot;分配磁带机&quot;, &quot;分配打印机&quot;, &quot;用户输入数据&quot;, &quot;刷新信息&quot;] for i in range(num): # self, pid, name, priority, in_time, run_time pcb_list.append(PCB(str(i), name_list[random.randint(0, 4)], random.randint(1, 9), random.randint(0, 10), random.randint(1, 9))) for i in range(len(pcb_list)-1): for j in range(i+1, len(pcb_list)): if pcb_list[i].in_time &gt; pcb_list[j].in_time: pcb_list[i],pcb_list[j] = pcb_list[j],pcb_list[i] return pcb_listdef NewList_record(num): pcb_list = [] #pid, name, priority, in_time, run_time for i in range(num): name = input(&quot;请输入%d号进程的名称：&quot; % i) priority = int(input(&quot;请输入%d号进程的优先级：&quot; % i)) in_time = int(input(&quot;请输入%d号进程的到达时间：&quot; % i)) run_time = int(input(&quot;请输入%d号进程的运行时间：&quot; % i)) pcb_list.append(PCB(str(i), name, priority, in_time, run_time)) for i in range(len(pcb_list) - 1): for j in range(i + 1, len(pcb_list)): if pcb_list[i].in_time &gt; pcb_list[j].in_time: pcb_list[i], pcb_list[j] = pcb_list[j], pcb_list[i] return pcb_listdef ScheduleSlect(list1): templist = copy.deepcopy(list1) def avg_output(list): AvgTurnaround_time = 0 AvgWTurnaround_time = 0 for i in list: AvgTurnaround_time += i.turnaround_time AvgWTurnaround_time += i.Wturnaround_time print(&quot;平均周转时间: &quot;+ str(round(AvgTurnaround_time / len(list), 2))+&quot;\\t&quot;+&quot;平均带权周转时间: &quot;+ str(round(AvgWTurnaround_time / len(list), 2))) while True: list1 = copy.deepcopy(templist) print(&quot;-&quot;*20) sch_num = input(&quot;1. 先来先服务 FCFS\\n2. 短作业优先 SJF\\n3. 时间片轮转 RR\\n4. 重新输入数据\\n请选择调度算法：&quot;) if sch_num == &quot;1&quot;: list2 = copy.deepcopy(list1) ListSort(list2) list1 = FCFS(list1) ListSort(list1) avg_output(list1) elif sch_num == &quot;2&quot;: list2 = copy.deepcopy(list1) ListSort(list2) list1 = SJF(list1) ListSort(list1) avg_output(list1) elif sch_num == &quot;3&quot;: list2 = copy.deepcopy(list1) ListSort(list2) list1 = RR(list1) ListSort(list1) avg_output(list1) elif sch_num == '4': break else: print(&quot;输入错误，请重新输入！&quot;)if __name__ == &quot;__main__&quot;: while True: pcb_num = int(input(&quot;请输入进程个数(输入0退出)：&quot;)) if pcb_num &lt; 1 or pcb_num &gt; 999: print(&quot;请输入正确的数据！&quot;) break input_type = int(input(&quot;1、随机生成\\n2、手工输入\\n请选择数据的输入方式：&quot;)) if input_type == 1: list1 = NewList_random(pcb_num) ScheduleSlect(list1) elif input_type == 2: list1 = NewList_record(pcb_num) ScheduleSlect(list1) else: print(&quot;输入有误，请重新输入！&quot;)","link":"/archives/b4dd2615.html"}],"tags":[{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"categories":[]}